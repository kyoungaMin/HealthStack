import json
import os

def generate_sql(input_file, output_file):
    if not os.path.exists(input_file):
        print(f"Input file not found: {input_file}")
        return

    with open(input_file, 'r', encoding='utf-8') as f:
        data = json.load(f)

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("-- Seed data for catalog_drugs from drug_product_permission.json\n")
        
        # INSERT loop
        for item in data:
            basic = item.get("basic", {})
            detail = item.get("detail", {}) or {}
            ingredients = item.get("ingredients", [])
            
            # Map fields
            id_value = basic.get("ITEM_SEQ")
            if not id_value: continue
            
            # Use ITEM_SEQ as id (it's numeric string, fit for bigint?)
            # catalog_drugs.id is bigint generated by default. 
            # We can use item_seq as id if we want stable IDs, but conflicting with auto-inc.
            # Let's use item_seq as a separate column 'code' or similar if schema has it.
            # Schema: 
            # catalog_drugs (id, name_ko, name_en, manufacturer, image_url, category, 
            #                description, ingredients, precau_precautions, usage, storage_method, 
            #                packaging, insurance_code, price, created_at, updated_at)
            
            # wait, catalog_drugs schema in full_schema.sql:
            # CREATE TABLE IF NOT EXISTS public.catalog_drugs (
            #   id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            #   name_ko TEXT NOT NULL, ...
            
            name_ko = basic.get("ITEM_NAME", "").replace("'", "''")
            name_en = basic.get("MAIN_ITEM_INGR", "") # Sometimes empty
            if not name_en:
                name_en = detail.get("MAIN_INGR_ENG", "")
            name_en = name_en.replace("'", "''")
            
            manufacturer = basic.get("ENTP_NAME", "").replace("'", "''")
            
            # Ingredients list to string
            ingr_list = []
            for ingr in ingredients:
                ingr_name = ingr.get("INGR_NAME", "")
                qty = ingr.get("INGR_QTY", "")
                unit = ingr.get("INGR_UNIT_NAME", "")
                if ingr_name:
                    ingr_list.append(f"{ingr_name} {qty}{unit}")
            
            ingredients_str = ", ".join(ingr_list).replace("'", "''")
            
            # Description from INDIVIDUAL_SC_SHAPE (Detail) or similar? 
            # Detail has 'CHART' (Shape)
            description = detail.get("CHART", "").replace("'", "''")
            
            # Usage, precautions, storage
            # The API returns these often as XML or huge text in other endpoints (e.g. DocInfo).
            # The current fetch script only gets basic & detail & ingredient. 
            # Detail might have STORAGE_METHOD_NAME
            storage = detail.get("STORAGE_METHOD_NAME", "").replace("'", "''")
            
            # Category (ETC_OTC_CODE)
            category = basic.get("ETC_OTC_CODE", "") # 전문의약품/일반의약품
            
            
            val = f"""
            INSERT INTO public.catalog_drugs (
                name_ko, name_en, manufacturer, category, description, ingredients, storage_method
            ) VALUES (
                '{name_ko}', '{name_en}', '{manufacturer}', '{category}', '{description}', '{ingredients_str}', '{storage}'
            );
            """
            f.write(val)

if __name__ == "__main__":
    base_dir = r"c:\AI\dev5"
    input_path = os.path.join(base_dir, "data", "drug_product_permission.json")
    output_path = os.path.join(base_dir, "supabase", "seed_catalog_drugs.sql")
    
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    generate_sql(input_path, output_path)
    print(f"Generated SQL: {output_path}")
